---
title: "Using Internal Data"
format:
  html:
    code-fold: show
jupyter: python3
---

In this lesson series we’ll use five input locations: **internal data** defined directly in code, **CSV files**, **Excel workbooks**, **Google Sheets** (via a share/export link), and **simple HTML tables from webpages**.

## When to Use Internal Data

When you’re just starting out, one of the easiest ways to work with data is to include it directly inside your program or notebook. Since everything is written in the same place, you don’t need to worry about opening extra files or setting up outside sources.

This approach works best when your dataset is small, maybe just a few rows of numbers or categories. It keeps things simple and lets you focus on how the data is being used, not on file management. Another bonus is that you can define both the column names and the values right in your code, making the table’s structure clear and easy to control.

### Step 1 — Import Libraries and Embed Data

In this step, we bring in needed tools (libraries) and define a simple dataset entirely in code. 

```{python}
# Import the libraries we need
import pandas as pd
import plotly.express as px

# Define simple data in code
x_data = [0, 1, 2, 3, 4, 5]
y_data = [0, 1, 4, 9, 16, 25]
print(x_data, y_data)
```

The two lists represent a basic relationship: each `y` is the square of the corresponding `x`. This kind of data is perfect for showing how tables and charts map numbers in columns → rows → plots.

### Step 2 — Create a DataFrame and Preview It

In this step, we turn the raw lists into a structured table (called a DataFrame) so it’s easier to see patterns and check for errors before plotting.

```{python}
# Create a DataFrame from the simple data, naming the columns
df = pd.DataFrame({"x": x_data, "y": y_data})
```

```{python}
# Preview the first few rows of the table
df.head()
```

You’ll see two columns (“x” and “y”) and six rows. This preview lets you verify your data is embedded correctly — columns are clearly labeled, rows line up with the `x` and `y` pairs, and nothing unexpected (like wrong types) is hiding.

### Step 3 — Plot a Scatter Plot

Now that you have a table, we’ll make a scatter plot to help us see how two variables relate (x vs. y here). Scatter plots are great for showing trends or patterns.

```{python}
fig = px.scatter(df, x="x", y="y", title="Example Scatter Plot: y = x²")
fig.show()
```

In this plot, each point is one (x, y) pair. As x increases, you’ll see y increasing faster (because y = x²). This visual helps you check whether your entered data worked and gives you intuition about relationships.

## Talk About It

* What do the column names (“x”, “y”) suggest about what each value means? How would you describe “x” and “y” to someone who knows nothing about this data?

* The example uses simple numbers where *y* = *x²*. If you changed “y” to something else (for example, *z = x³* or *y = 2x*), how would the scatter plot change, and what questions could that let you ask?

* Are there limitations with data you’ve embedded in code (like this)? What is one thing this dataset can’t show you, and why?

## Lesson Notebook

Now it’s your turn to practice: The notebook version includes one exercise where you’ll use provided lists to plot Pascal Siakam’s field goals made over his Raptors career—applying the same setup → input → output flow you saw above.

Open the lesson [here](https://github.com/Data-Dunkers/lessons/blob/main/data-from-internal.ipynb).
